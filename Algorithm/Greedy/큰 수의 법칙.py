# 큰 수의 법칙
# 2019 국가 교육기관 코딩 테스트
# 다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만드는 방법
# 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것
#   ex) [2, 4, 5, 4, 6] , M=8, K=3 -> 큰 수의 법칙 : 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46 
	
# 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에 서로 다른 것으로 간주
#	ex) [3, 4, 3, 4, 3], M=7, K=2 -> 큰 수의 법칙 : 4 + 4 + 4 + 4 + 4 + 4 + 4 = 28
	
# 배열의 크기N, 숫자가 더해지는 횟수M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.
# -----------------------------------------------------------------------------------------------------------
# 결과( N = 5, M = 100,000,000, K = 5) sum = 583333334
# 방법 1 -> 26.651346683502197초
# 방법 2 ->  0.0초

# -----------------------------------------------------------------------------------------------------------
import time
# 입력
N, M, K = map(int, input().split())
L = list(map(int, input().split()))
# 리스트 내림차순 정렬
start = time.time()
L.sort(reverse = True)
sum = 0

# 방법 1 -> M <= 10000 
for i in range(1, M+1):
	if i%(K+1) != 0:
		sum += L[0]
	else:
		sum += L[1]

# 방법 2 수열의 규칙성으로 구하기(반복문x)
sum += (M//(K+1)) * (L[0]*K+L[1])
sum += (M%(K+1)) * L[0]

print(sum)
print(time.time()-start)

# 알고리즘은 위대하다.....